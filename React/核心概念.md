1、JSX简介：
考虑如下变量声明：
```
const element = <h1>Hello, world!</h1>
```
为JSX，是JavaScript的语法扩展，可很好描述UI应该呈现出他应有交
互的本质形式，它具有JavaScript的全部功能

为什么使用JSX：
React认为渲染逻辑本质上与其他UI逻辑内在耦合，比如，在UI中需要
绑定处理事件、在某些时刻状态发生变化时需要通知到UI，以及需要在
UI中展示准备好的数据
React并没有采用将标记与逻辑进行分离到不同文件这种人为分离方式，
通过将二者共同存放在“组件”的松散耦合单元中实现关注点分离。
React中不强制要求使用JSX，在JavaScript中将JSX和UI放一起时，会
有视觉上的辅助作用，同时，可使React显示更多有用错误和警告消息。

在JSX中嵌入表达式：
```
const name = 'Josh Perez'
const element = <h1>Hello, {name}</h1>
ReactDOM.render(
  element,
	document.getElementById('root')
)
```

可在{}中放置任何有效的JavaScript表达式，如2+2，user.firstName等
如：
```
function formatName(user){
	return user.firstName + '' + user.lastName
}
const user = {
	firstName: 'Harper,
	lastName: 'Perez'
}
const element = (
	<h1>
		Hello, {formatName(user)}
	</h1>
)
ReactDOM.render(
	element,
	document.getElementById('root')
)
```

JSX也是一个表达式：
编译之后JSX表达式转换成JavaScript函数调用，对其取值后得到JavaScript对象
如：
```
function getGreeting(user){
	if(user){
		return <h1>Hello,{formatName(user)}!</h1>
	}
	return <h1>Hello,Stranger.</h1>
}
```

使用程序管理焦点：
有时候键盘焦点会丢失。
```
class CustomTextInput extends React.Component{
	constructor(props){
		super(props)
		// 创建一个 textInput DOM 元素的 ref
		this.textInput = React.createRef()
	}
	render(){
		// 使用 `ref` 回调函数以再实例的一个变量中存储文本输入DOM元素
		// （比如，this.textInput）
		return (
			<input
				type='text'
				ref={this.textInput}
			/>
		)
	}
}
focus(){
	// 使用原始的 DOM API 显式地聚焦在 text input 上
	// 注意：我们通过访问 'current' 来获得DOM节点
	this.textInput.current.focus()
}
```
父组件将焦点设置在其子组件的一个元素上：
```
function CustomTextInput(props){
	return (
		<div>
			<input ref={props.inputRef}/>
		</div>
	)
}
class Parent extends React.Component{
	constructor(props){
		super(props)
		this.inputElement = React.createRef()
	}
	render(){
		return (
			<CustomTextInput inputRef={this.inputElement} />
		)
	}
}
// 现在可以在需要时设置焦点
this.inputElement.current.focus()
```

鼠标和指针事件   
确保任何可以使用鼠标和指针完成的功能也可以只通过键盘完成。     
    
更复杂的部件   
尽可能接近HTML编程  
   
Suspense:   
在某个组件还未加载完成，可以通过使用加载指示器如Suspense组件来做优雅降级    
```
const OtherComponent = React.lazy(() => import('./OtherComponent'))
function MyComponent(){
	return (
		<div>
			<Suspense fallback={<div>Loading...</div>}>
				<OtherComponent />
			</Suspense>
		</div>
	)
}
```
可以用一个Suspense组件包裹多个懒加载组件   
   
命名导出：    
React.lazy目前只支持默认导出

Context：    
Context可以共享对于一个组件树来说是“全局”的数据   
```
// Context 可以让我们无需明确地传递每一个组件，就能将值深入传递进组件树
// 为当前的 theme 创建一个 context ("light"为默认值)
const ThemeContext = React.createContext('light')
class App extends React.Component{
	render(){
		// 使用一个 Provider 来将当前的 theme 传递给以下的组件树
		// 无论多深，任何组件都能读取到这个值
		// 在这个例子中，我们将 “dark” 作为当前的值传递下去
		return (
			<ThemeContext.Provider value='dark'>
				<Toolbar />
			</ThemeContext.Provider>
		)
	}
}
// 中间的组件再也不必指明往下传递 theme 了
function Toolbar(props){
	return (
		<div>
			<ThemeButton />
		</div>
	)
}
class ThemeButton extends React.Component{
	// 指定 contextType 读取当前的 theme context
	// React 会往上找到最近的 theme Provider，然后使用它的值
	// 在这个例子中，当前的 theme 值为“dark”
	static contextType = ThemeContext
	render(){
		return <Button theme={this.context}></Button>
	}
}
```
    
错误边界：    
一种React组件，可以捕获并打印发生在其子组件树任何位置的JavaScript错误，并且，会渲染出备用UI，只针对React，仅可以捕获其子组件的错误     
无法捕获场景：    
事件处理    
异步代码（如setTimeout或requestAnimationFrame回调函数）    
服务端渲染     
他自身抛出来的错误    
可用生命周期函数   
```
static getDeivedStateFromError()
static componentDidCatch()
```  
React16起，任何未被错误边界捕获的错误将会导致整个React组件树被卸载  
React事件处理器不会再渲染期间触发，如果需要在事件处理器内部捕获错误，可以使用try/catch语句    

Refs转发：    
Ref转发是一个可选特性，允许某些组件接收ref，并将其向下传递给子组件  
```
const FancyButton = React.forwardRef((props, ref) => (
	<button ref={ref} className='FancyButton'>
		{props.children}
	</button>
))
// 可以直接获取 DOM button 的ref
const ref = React.createRef()
<FancyButton ref={ref}>Click Me!</FancyButton>
```
在HOC中使用：    
```
function logProps(Component){
	class LogProps extends React.Component{
		componentDidUpdate(prevProps){
			console.log('old props: ',prevProps)
			console.log('new props: ',this.props)
		}
		render(){
			const {forwardedRef, ...rest} = this.props
			// 将自定义的 prop 属性“forwardedRef”定义为 ref
			return <Component ref={forwardedRef} {...rest} />
		}
	}
	// 注意 React.forwardRef 回调的第二个参数“ref”
	// 我们可以将其作为常规 prop 属性传递给 LogProps，如"forwardedRef"
	// 然后他就可以被挂载到被 LogProps 包裹的子组件上
	return React.forwardedRef((props, ref) => {
		return <LogProps {...props} forwardedRef={ref} />
	})
}
```

Fragments：     
Fragments允许你将字列表分组，无需向DOM添加额外结点
```
render(){
	return (
		<React.Fragment>
			<ChildA />
			<ChildB />
			<ChildC />
		</React.Fragment>
	)
}
```
短语法：不支持key或属性   
```
class Columns extends React.Component{
	render(){
		return (
			<>
				<td>Hello</td>
				<td>World</td>
			</>
		)
	}
}
```

HOC：参数为组件，返回值为新组件的函数    
通过将组件包装在容器组件中来组成新组件，HOC是纯函数，没有副作用    
HOC组件之间的契约完全基于之间传递的props    
不要在HOC中修改组件原型（或以其他方式改变它）  
 



















