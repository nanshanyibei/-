动态规划核心：Those who cannot remember the past are condenmned to repeat it.   
  
适用类型：  
1、最优化原理：如果问题的最优解包含的子问题也是最优解的，即满足最优化原理。  
2、无后效性：某阶段状态一旦确定，不受这个状态以后决策是影响。  
3、有重叠子问题：子问题之间是不独立的，一个子问题在下一个阶段决策中可能被多次使用。   
  
一般思路：  
确定决策，找出状态转移方程，确定终止条件   
  
重难点：找出状态转移方程   
   
动态规划典型应用--01背包：  
题目：有5件物品和1个容量为10的背包，每种物品均只有一件，第i件物品的重量为weights[i]，   
物品重量weights=[2,2,6,5,4]，价值为values[i]。求解将哪些物品放入背包可使价值总和最大。  
  
分析：   
拿到这种题型的时候就在本子上写写画画吧，之后找出规律，可以列出如下表格：   
w  v  i\j  0  1  2  3  4  5  6  7  8  9  10   
2  6   0   0  0  6  6  6  6  6  6  6  6   6   
2  3   1   0  0  6  6  9  9  9  9  9  9   9   
6  5   2   0  0  6  6  9  9  9  9  11 11  14   
5  4   3   0  0  6  6  9  9  9  10 11 13  14    
4  6   4   0  0  6  6  9  9  12 12 15 15  15  
之后可以列出如下公式：  
					0																				, j < wi and i = 0   
					v0																			, j >= wi and i = 0  
f(i,j) =  f(i - 1, j)															, j < wi and i > 0   
					max{ f(i - 1, j),f(i - 1, j - wi) + vi} , j >= wi and i > 0  
由上面的公式可以写出代码  
  
代码：   
function knapsack(weights, values, W) {  
  const n = weights.length -1   
  let f = [[]]   
  for (let j = 0; j <= W; j++) {   
    if (j < weights[0]) {  
      f[0][j] = 0   
    } else {   
      f[0][j] = values[0]   
    }  
  }   
  for (let j = 0; j <= W; j++) {   
    for (let i = 1; i <= n; i++ ) {   
      if (!f[i]) {   
        f[i] = []   
      }   
      if (j < weights[i]) {   
        f[i][j] = f[i-1][j]   
      } else {   
        f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i])    
      }   
    }   
  }   
  return f[n][W]  
}


