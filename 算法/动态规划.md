动态规划核心：Those who cannot remember the past are condenmned to repeat it.   
  
适用类型：  
1、最优化原理：如果问题的最优解包含的子问题也是最优解的，即满足最优化原理。  
2、无后效性：某阶段状态一旦确定，不受这个状态以后决策是影响。  
3、有重叠子问题：子问题之间是不独立的，一个子问题在下一个阶段决策中可能被多次使用。   
  
一般思路：  
确定决策，找出状态转移方程，确定终止条件   
  
重难点：找出状态转移方程   
   
动态规划典型应用--01背包：  
题目：有5件物品和1个容量为10的背包，每种物品均只有一件，第i件物品的重量为weights[i]，   
物品重量weights=[2,2,6,5,4]，价值为values[i]。求解将哪些物品放入背包可使价值总和最大。  
  
分析：   
拿到这种题型的时候就在本子上写写画画吧，之后找出规律，可以列出如下表格：  
<table border="1px" align="center" cellspacing="0" bordercolor="black" width="80%">
    <tr align="center">
        <td>w</td>
        <td>v</td>
        <td>i/j</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
        <td>5</td>
        <td>6</td>
        <td>7</td>
        <td>8</td>
        <td>9</td>
        <td>10</td>
    </tr>
    <tr align="center">
        <td>2</td>
        <td>6</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
        <td>6</td>
    </tr>
    <tr align="center">
        <td>2</td>
        <td>3</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>6</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
    </tr>
    <tr align="center">
        <td>6</td>
        <td>5</td>
        <td>2</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>6</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>11</td>
        <td>11</td>
        <td>14</td>
    </tr>
    <tr align="center">
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>6</td>
        <td>9</td>
        <td>9</td>
        <td>9</td>
        <td>10</td>
        <td>11</td>
        <td>13</td>
        <td>14</td>
    </tr>
    <tr align="center">
        <td>4</td>
        <td>6</td>
        <td>4</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>6</td>
        <td>9</td>
        <td>9</td>
        <td>12</td>
        <td>12</td>
        <td>15</td>
        <td>15</td>
        <td>15</td>
    </tr>
</table>  

之后可以列出如下公式：  
```
    	   0						             	, j < wi and i = 0   
		   v0						                , j >= wi and i = 0  
f(i,j) =   f(i - 1, j)	      	             	, j < wi and i > 0   
		   max{ f(i - 1, j),f(i - 1, j - wi) + vi}   , j >= wi and i > 0  
```
由上面的公式可以写出代码  
  
代码：   
```
function knapsack(weights, values, W) {  
  const n = weights.length -1   
  let f = [[]]   
  for (let j = 0; j <= W; j++) {   
    if (j < weights[0]) {  
      f[0][j] = 0   
    } else {   
      f[0][j] = values[0]   
    }  
  }   
  for (let j = 0; j <= W; j++) {   
    for (let i = 1; i <= n; i++ ) {   
      if (!f[i]) {   
        f[i] = []   
      }   
      if (j < weights[i]) {   
        f[i][j] = f[i-1][j]   
      } else {   
        f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i])    
      }   
    }   
  }   
  return f[n][W]  
}
```